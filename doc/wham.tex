\documentclass[aip,jcp,preprint,superscriptaddress]{revtex4-1}
\usepackage{amsmath}
\usepackage{tikz}
\begin{document}




\newcommand{\vct}[1]{\mathbf{#1}}



\section{Introduction}



The multiple histogram method\cite{
ferrenberg1988, *ferrenberg1989}
or its generalization,
the weighted histogram analysis method (WHAM)\cite{
kumar1992, souaille2001, kastner2005,
chodera2007, bereau2009,
kim2011},
is a popular method of estimating
the free energy difference
between thermodynamic states
of different conditions (e.g. temperature and pressure).
%
The method iteratively solves a pair of coupled equations of
the free energy and the density of states
involving the energy histograms, hence the name.
%
Although the original formulation is
based on histograms,
this restriction can be lifted,
resulting in the
multistate Bennett acceptance ratio (MBAR) method\cite{
shirts2008},
which direct extends the original
Bennett acceptance ratio (BAR) method\cite{
bennett1976}.



Although powerful,
the standard implementation of WHAM or MBAR can suffer from
a slow convergence in later stages.
%
Several remedies are proposed\cite{
 shirts2008, bereau2009, kim2011}.
%
For example, one may use the Newton-Raphson method
to directly compute the Hessian matrix\cite{
shirts2008},
although it can be occasionally unstable.
%
An ingenious non-iterative alternative
is to directly estimate the derivative of density of states,
leading to the statistical-temperature WHAM\cite{
kim2011}.
%
This variant, however, gives
a slightly different free energy from the original WHAM,
and the extension to multiple-dimensional,
e.g., isothermal-isobaric, ensembles
is not obvious.



Here, we consider improving WHAM using
the method of direct inversion in the iterative subspace (DIIS)\cite{
pulay1980, *pulay1982, *hamilton1986}.
%
Particularly, we consider a modification
popular in the liquid state theory\cite{
kovalenko1999, howard2011}.




\section{Method}



\subsection{WHAM}



The multiple histogram method or WHAM,



\subsection{DIIS}


\tikzstyle{emptydot}=[inner sep=0pt,minimum size=0.0mm]
\tikzstyle{fRarrow}=[->, thick, draw=blue!30!gray]
\tikzstyle{fRarr}=[->, thin, draw=blue!25!white]
\tikzstyle{farr}=[->, thin, draw=black!25!white]
\tikzstyle{fRlabel}=[inner sep=0pt, text=black!80!white]

\begin{figure}
  \begin{tikzpicture}
    \newcommand{\sz}{4cm}
    %
    %
    % The potential function to minimize is
    %
    % F = 3/8 (x - 3/5)^2 + 5/8 (y - 4/5)^2 + 1/4 (x - 3/5) (y - 4/5)
    %   = 7/2 R^2
    %
    % x = 3/5
    %   + (sqrt(2) - 1) sqrt(3 + sqrt(2)) cos t
    %   + (sqrt(2) + 1) sqrt(3 - sqrt(2)) sin t.
    %
    % y = 4/5
    %   + sqrt(3 + sqrt(2)) cos t
    %   - sqrt(3 - sqrt(2)) sin t.
    %
    % The long axis is achieved at t = Pi/2
    % its length is sqrt(8 + 2 sqrt(2)) R,
    % and it is along the direction of
    %   (sqrt(2) + 1, -1),
    % which has an angle of -22.5 degrees
    % with the x axis.
    %
    % The short axis is achieved at t = 0,
    % its length is sqrt(8 - 2 sqrt(2)) R,
    % and it is along the direction of
    %   (sqrt(2) - 1, 1),
    % which has an angle of 67.5 degrees
    % with the x axis.
    %
    %
    %
    % Draw ellipse I, for vector f1
    %
    % R = sqrt(19/7)/5
    %
    \newcommand{\longI}{3.2906576*0.3295017884*\sz}
    \newcommand{\shortI}{2.274109*0.3295017884*\sz}
    %
    \draw[fill, black!7!white, rotate around={67.5:(0.6*\sz, 0.8*\sz)}]
      (0.6*\sz, 0.8*\sz)
      ellipse ({\shortI} and {\longI});
    %
    % Draw ellipse II, for vector f2
    %
    % R = sqrt(13/14)/5
    %
    \newcommand{\longII}{3.2906576*0.1927248223*\sz}
    \newcommand{\shortII}{2.274109*0.1927248223*\sz}
    %
    \draw[fill, black!10!white, rotate around={67.5:(0.6*\sz, 0.8*\sz)}]
      (0.6*\sz, 0.8*\sz)
      ellipse ({\shortII} and {\longII});
    %
    %
    %
    \foreach \i in {1,...,19}
    {
      \pgfmathsetmacro\lambda{\i * 0.05}
      \pgfmathsetmacro\x{1 - \lambda}
      \pgfmathsetmacro\y{\lambda}
      \pgfmathsetmacro\dx{-0.1 + 0.5 * \lambda}
      \pgfmathsetmacro\dy{0.9 - 1.0 * \lambda}
      \pgfmathsetmacro\xx{\x + \dx}
      \pgfmathsetmacro\yy{\y + \dy}
      \draw [farr] (0, 0) -- (\x*\sz, \y*\sz);
      \draw [fRarr] (\x*\sz, \y*\sz) -- (\xx*\sz, \yy*\sz);
    }
    %
    %
    %
    % the minimum
    %
    %
    \draw
        (0.6*\sz, 0.8*\sz)
        node
          [ fill, circle, inner sep=0pt, minimum size=1.5mm,
            label={
              [inner sep=0.01*\sz]
              -45:{$\vct f^*$}
            }
          ] {};
    %
    % vector 1
    %
    \node (f1R1) at (0.9*\sz, 0.9*\sz)
      [ emptydot,
        label={[fRlabel,
                label distance={0.05*\sz},
                rotate=-83.7]
             20:{$\vct R_1$}}
      ] {};
    \node (f1) at (1.0*\sz, 0)
      [emptydot, label=below:{$\vct f_1$}]{}
      edge[fRarrow] (f1R1);
    %
    % vector 2
    %
    \node (f2R2) at (0.4*\sz, 0.9*\sz)
      [ emptydot,
        label={[fRlabel,
                label distance={0.03*\sz},
                rotate=-14.0]
             93:{$\vct R_2$}}
      ] {};
    \node (f2) at (0, 1.0*\sz)
      [emptydot, label=left:{$\vct f_2$}]{}
      edge[dashed, thin] (f1)
      edge[fRarrow] (f2R2);
    %
    %
    % optimal vector
    %
    %
    \node (fhatRhat) at (0.52*\sz, 0.9*\sz)
      [ emptydot,
        label={[fRlabel,
                label distance={0.02*\sz},
                rotate=26.6]
              -150:{$\vct {\hat R}$}}
      ] {};
    \node (fhat) at (0.24*\sz, 0.76*\sz)
      [ emptydot, inner sep=0,
        label={
          [label distance={0.03*\sz}]
          180:{$\vct {\hat f}$}
        }
      ] {}
      edge[fRarrow] (fhatRhat);
    %
    %
    %
    \node (origin) at (0, 0) [emptydot]{}
      edge[->, very thick] (f1)
      edge[->, very thick] (f2)
      edge[->, very thick] (fhat);
    %
    %
    %
    %
    % origin of the residual vectors
    %
    %
    %
    \newcommand{\Rox}{1.9*\sz}
    \newcommand{\Roy}{0.15*\sz}
    %
    %
    %
    \foreach \i in {1,...,19}
    {
      \pgfmathsetmacro\lambda{\i * 0.05}
      \pgfmathsetmacro\dx{-0.1 + 0.5 * \lambda}
      \pgfmathsetmacro\dy{0.9 - 1.0 * \lambda}
      \draw [fRarr]
        (\Rox, \Roy) -- (\Rox + \dx*\sz, \Roy + \dy*\sz);
    }
    %
    %
    %
    \node (R1) at ({\Rox-0.1*\sz}, {\Roy+0.9*\sz})
      [ emptydot,
        label={[fRlabel]90:{$\vct R_1$}}
      ] {};
    %
    %
    %
    \node (R2) at ({\Rox+0.4*\sz}, {\Roy-0.1*\sz})
      [ emptydot,
        label={[fRlabel, label distance=1.5mm]
               -90:{$\vct R_2$}}
      ] {}
      edge[dashed, thin] (R1);
    %
    %
    %
    \node (Rhat) at ({\Rox+0.28*\sz}, {\Roy+0.14*\sz})
      [ emptydot,
        label={[fRlabel, label distance=0.1mm]
               10:{$\vct {\hat R}$}}
      ] {};
    %
    %
    %
    \node (Rorigin) at (\Rox, \Roy) [emptydot] {}
      edge[fRarrow] (R1)
      edge[fRarrow] (R2)
      edge[fRarrow] (Rhat);
    %
    %
    %
  \end{tikzpicture}
  %
  %
  %
  \caption{\label{fig:scheme}
    Schematic illustration of the method of
    direct inversion of the iterative subspace (DIIS).
    %
    The aim is to solve a set of equation.
    %
    Each trial vector $\vct f_i$
    represents an approximate solution,
    and the residual vector $\vct R_i$
    represents the error.
    %
    Given a basis of a few (two here) trial vectors,
    DIIS seeks the combination
    $\vct {\hat R} = \sum_i c_i \, \vct R_i$
    that achieves the minimal magnitude
    under the constraint
    $\sum_i c_i = 1$.
    %
    The coefficients, $c_i$, are used
    to combine the trial vectors as
    $\vct {\hat f} = \sum_i c_i \, \vct f_i$.
    %
    The new trial vector is given by
    $\vct f^{(n)} = \vct {\hat f} + \vct {\hat R}$.
    %
    For the next round of iteration,
    $\vct f^{(n)}$ is normally either added
    to the basis, or used to replace an existing vector
    in the basis.
  }
\end{figure}




The mixing factor is $1.0$ in this study.



\subsection{Basis updating}



The basis is then updated by the new vector.
%
In a popular updating scheme\cite{kovalenko1999},
we add the new vector to the basis,
if there is fewer than $M$ vectors in the basis,
%
or replace the earliest vector by the new vector.
%
If, however, the new vector
produces an error greater than
(in terms of the norm of residual vector)
$K_r$ (here, $K_r = 10.0$ as recommended)
times the minimal error of the basis,
%
we rebuild the basis
from the least erroneous vector in basis.



An alternative is the following.
%
First, we find the most erroneous vector,
$\vct u_m$, from the basis.
%and compute its error, $\varepsilon(\vct u_m)$.
%
If the new vector, $\vct v$,
produces an error less than $\vct u_m$,
we add $\vct v$ into the basis
(and remove $\vct u_m$ if the basis is full).
%
Otherwise,
we remove $\vct u_m$ from the basis
and if this leaves the basis empty,
we rebuild the basis from $\vct v$.
%
% We find the modification is slightly better.



\section{Results}



The method is tested on three systems.


The first is the two-dimensional $64\times64$ Ising model.


Lennard-Jones, canonoical ($NVT$), isothermal-isobaric ($NPT$) ensemble.



Molecular system of villin headpiece,
The protein is immersed in
a dodecahedron box with 1898 water molecules and two chloride ions.
%
Both $NVT$ and $NPT$ ensembles are used.





\section{Acknowledgements}



It is a pleasure to thank Dr. Y. Zhao
for many helpful discussions.
%
Computer time on the Lonestar supercomputer
at the Texas Advanced Computing Center
at the University of Texas at Austin
is gratefully acknowledged.



\bibliography{simul}
\end{document}
